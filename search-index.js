znaiSearchData = [["entry@@testing-makes-you-faster-day-one@@tests-are-here-to-speed-you-up","Entry","Testing Makes You Faster Day One","Tests Are Here To Speed You Up","\"I am not writing tests right now as they are going to slow me down\" is one of the most common excuses I heard in the projects I worked on.A lack of test writing experience can make you feel this way, but I think there is another, bigger reason for the perception that tests slow you down. I believe this reason is actually an untapped superpower: the power of exercising any piece of your software in O(1) keystrokes. By O(1) I mean that regardless of how big your application becomes you will always be one button away of seeing the impact of your changes.The superpower of having the tightest feedback loop.Let me try to explain."],["entry@@testing-makes-you-faster-day-one@@building-a-medieval-castle","Entry","Testing Makes You Faster Day One","Building A Medieval Castle","We are going to build a Castle, add features to it, and do a manual inspection of our creation as we go.Let's start small. All we need is a single room and a throne to sit on.Perfect! So let's test it. Quickly get in, walk through the room, sit on the throne. All is good.Let's add a few more rooms and a chest.Our goal is to test if we can open that chest. This time we have to do a little bit more legwork. This time, a simple check took us a few minutes longer.Let's add a bit of security to our castle by adding keys and levers.We have to test each door and to do that we need to go through our entire castle. This makes a good test and a very important one.For our next iteration we decided to add a new smart lock to our chest, so we can open it with our retina.We gotta test this feature. So we open a jar, to pick a key, to open first one door and then to open the other door, to pull the lever, to run the stairs through the opened door. After catching our breath we try to open a chest.A day later, we decide to add an auto lock after three failed attempt. And so we bring a friend who is not registered with our castle to open a jar, to pick a key, to open a door, ... to ..., ..., to try to fail to open a chest.A few iterations later the Security Department expressed the concern that our security could use an upgrade. A trap, puzzle and a dragon later we are ready to deploy.As before, we gotta test every new added Security feature. This is a good test and a very important one. We get caught in a trap, we jump over the trap, we play rock/paper/scissors to lose and to win, open the door, get eaten by the dragon, defeat the dragon and finally reach the chest. All tests passed.Another development iteration passes and we decided to make scissors game to be lefty friendly.And so we bring a friend who is a lefty, can jump over traps, to open a jar, to pick a key, to open a door, to jump over trap, to open a door, to play rock/paper/scissorsA day later we decided to add a fingerprint reader to our chestAnd so we bring another friend who is a lefty, who is not registered with our castle, who can jump over traps, who won't be scared of a dragon, to open a jar, to pick a key, to open a door, to jump over trap, to open a door, to play rock/paper/scissors, to open a lever, to challenge a dragon, to put a finger to a chest.It should be clear by now that the more features we add to the castle, the more time it takes to do a check routine of a single feature. What is interesting is that the big portion of the time is spend getting to the feature we want to test and not the test itself.Having said all that let's add another floor to the castle.There is a new room where you can grab any gear you want and also play a loot box game. Don't worry we won't be running through the castle to test loot box game algorithm (one entire castle run for a single try)Instead, we will create teleports"],["entry@@testing-makes-you-faster-day-one@@teleports-system","Entry","Testing Makes You Faster Day One","Teleports System","Instead of running around the castle, fighting dragons and jumping over traps, wouldn't it be easier to just appear in certain castle places to perform our routines?Let's add a teleport right next to our new loot box game. Next time we tweak loot algorithm we won't run around the castle, we just show up right where we need to be.Regardless of how big our castle will become, regardless of how many more traps and doors we will add between the castle entrance and the loot floor, when we need to tweak and test our loot box algorithm, we just show up right there.Let's add teleports next to more points of interests, so next time when we tweak our features we can test them in an instance.On our first day we only had one room and a throne at the end. But if on the same day we would add a teleport next to the throne - we would already be saving time running through the room.Teleporting would make us faster day one."],["entry@@testing-makes-you-faster-day-one@@implementing-teleports","Entry","Testing Makes You Faster Day One","Implementing Teleports","The castle we have built is your app. And the main entrance is your language main function.One way to build teleports is to implement more than one main file with its own main function. java class ChestTeleport { public static void main() { FingerAuth wrongAuth = new FingerAuth('wrongPerson'); SmartLockChest chest = new Chest(); assert !chest.open(wrongAuth); FingerAuth validAuth = new FingerAuth('validPerson'); SmartLockChest chest = new Chest(); assert chest.open(validAuth)); } } If you do just that it is already going to be a time saver. Any time you want to test a different portion of your castle, you just use a different teleport - a different file to execute.As the number of teleports grow it may become harder to sort through them to pick one to use. Also teleports that are rarely used may become obsolete and point you to non existing parts of your castle.Fortunately most languages have a testing framework to define and structure your teleports. Moreover they will make sure that teleports are still functioning. java class ChestTest { @Test public void invalidFingerAuth() { FingerAuth wrongAuth = new FingerAuth('wrongPerson'); SmartLockChest chest = new Chest(); Assert.assertFalse(chest.open(auth)); } @Test public void validFingerAuth() { FingerAuth validAuth = new FingerAuth('validPerson'); SmartLockChest chest = new Chest(); Assert.assertTrue(chest.open(auth)); } } This is the untapped power of tests I was talking about at the beginning - the power to exercise any piece of your software in one button press. Regardless of how large or small you software is, tweaking your castle and validating it in a matters of seconds using an ever growing system of teleports will make you consistently productive on day one, day two, day hundred and day thousand."],["entry@@testing-makes-you-faster-day-one@@real-life-boring-example","Entry","Testing Makes You Faster Day One","Real Life Boring Example","You probably don't face castles and dragons every day at your work, so let me map it to a boring real life example.Let's add a page to Enterprise Corporate Website. Page will list employees that have birthdays today. List must be in an alphabetic order.Your fire up your IDE, write new page, deploy to DEV environment and test it. All looks good. A minute later you realize that your company doesn't have employees with the same last name that have birthdays on the same day. So how do you test this scenario?You create a SysAdmin Ticket to request WRITE access to DEV database. Wait for approval. Restart the server and check your code.Note: You may say, but hey, I can run my database locally! Sure, but not every big company and not every software has moved on to the greatest tech. And most excuses for not writing tests come from Enterprise engineers working on legacy applications. Plus it helps to make a point.Your code is in production for a month. Everyone is happy, the page is a great success and have many daily visitors. Hence a new request comes up: you need to change the sorting works. text Smith Bo Smith Bob Smith Bobed Smith Al Smith Alice text Smith Alice Smith Al Smith Bobed Smith Bob Smith Bo Basically, still sort alphabetically, but put longer names at the top. It makes page looks better!You fire up your DEV to realize the data is gone. You create a SysAdmin Ticket to request WRITE access to DEV database. Wait for approval. Restart the server and start coding.Let's rewind and try again. Instead of jumping to deploy and database manipulations, let's build a teleport. java class EmployeesSorterTest { @Test public void matchingLastName() { EmployeesList list = new EmployeesList(); list.add(\"Smith\", \"Bobed\"); list.add(\"Smith\", \"Alice\"); list.add(\"Smith\", \"Al\"); list.add(\"Smith\", \"Bob\"); EmployeesSorter employeesSorter = new EmployeesSorter(); EmployeesList sorted = employeesSorter.sort(list); Assert.assertEqual(\"Alice\", sorted.get(0).getFirstName()); Assert.assertEqual(\"Al\", sorted.get(1).getFirstName()); Assert.assertEqual(\"Bobed\", sorted.get(2).getFirstName()); Assert.assertEqual(\"Bob\", sorted.get(3).getFirstName()); } } Whether you implement EmployeesSorterTest first or EmployeesSorter is not that important to me.What important is you have a very tight feedback loop between your changes and the result. You bypass database admins (ahem, dragon, ahem, JK), web pages, internal auth systems and get straight to the business logic at hand."],["entry@@testing-makes-you-faster-day-one@@summary","Entry","Testing Makes You Faster Day One","Summary","Having a tight feedback loop is important for being efficient engineer. Tests are your teleports into any part of your application. Tests make you fast."],["entry@@protect-your-future-self-by-encapsulating-test-input-preparation@@tests-brittleness-and-verbosity-slows-you-down","Entry","Protect Your Future Self By Encapsulating Test Input Preparation","Tests Brittleness and Verbosity slows you down","In entry/testing-makes-you-faster-day-one Testing Makes You Faster Day one article I claimed that writing tests makes you faster. However, there are test patterns that most likely will slow you down and you need to be ready to handle them.Writing tests for a simple logic with a simple input is a breeze. Take for example a test for a simple calculator class. Two numeric inputs and we are done: package com.example.portfolio; import org.junit.Assert; import org.junit.Test; public class SimpleCalculatorTest { @Test public void zeroMultiply() { SimpleCalculator simpleCalculator = new SimpleCalculator(); Assert.assertEquals(0, simpleCalculator.multiply(100.0, 0.0), 0.0); Assert.assertEquals(0, simpleCalculator.multiply(-100.0, 0.0), 0.0); } } However real apps require real domain, and real domain is rarely represented by a couple of numbers. Let's take Finance as an example. It is full of types with multiple fields such as Transaction , and it has a lot of business logic.One example of such business logic is ProfitCalculator . Its job is to calculate profit based on the executed Transactions .After consulting with the business people, we are ready to give our implementation a shot. Transaction is a data class with a few fields (number of fields is reduced for simplicity). package com.example.portfolio; import javax.persistence.Entity; import javax.persistence.Id; @Entity public class Transaction { private String id; private double lot; private double price; private String symbol; @Id public String getId() { return id; } public void setId(String id) { this.id = id; } public double getLot() { return lot; } public void setLot(double lot) { this.lot = lot; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public String getSymbol() { return symbol; } public void setSymbol(String symbol) { this.symbol = symbol; } } Here is our first ProfitCalculator implementation, ready to be tested. package com.example.portfolio; import java.util.List; public class ProfitCalculator { public ProfitCalculator() { } public double calculate(List<Transaction> transactions) { return 0; } } And here is the first version of our test. package com.example.portfolio; import org.junit.Test; import java.util.Arrays; import static org.junit.Assert.assertEquals; public class ProfitCalculatorWithoutEncapsulationTest { private final ProfitCalculator profitCalculator = new ProfitCalculator(); @Test public void profitShouldBeZeroIfNoLotsSet() { Transaction t1 = new Transaction(); t1.setId(\"T1\"); t1.setSymbol(\"SYM.B\"); t1.setLot(0); t1.setPrice(8); Transaction t2 = new Transaction(); t1.setId(\"T2\"); t1.setSymbol(\"SYM.C\"); t1.setLot(0); t1.setPrice(19); assertEquals(0, profitCalculator.calculate(Arrays.asList(t1, t2)), 0); } } This test is already on the verbose side. As requirements for the ProfitCalculator evolve, the number of setters we need to validate new business logic will grow, as will grow the number of instances that we may need to create.Question: But why verbose test can be bad? A verbose test can be bad, because the boilerplate code used to setup the test makes it harder to read intent behind the test. Additionally it may discourage you to write separate test scenario and instead you may want to clump test scenarios together and re-use the test data setup. Test data re-use can lead to a random test being broken as you setup data for an unrelated scenario. Verbosity is not the only potential problem here. The way Transaction instance is being constructed for testing purposes can lead to a maintenance burden.The First iteration of Transaction class uses setters to set the data. A future iteration may switch to using fluent API instead of setters . transaction(\"T1\") .symbol(\"SYM.B\") .lot(0) .price(0); From the ProfitCalculator 's perspective the way Transaction instances are created is irrelevant as it doesn't affect the calculation logic. But refactoring Transaction will break ProfitCalculatorTest . Transaction is going to be used in other tests. As the number of tests that use Transaction instances increases you will be more and more reluctant to do refactoring. All your tests that create Transaction instances are brittle tests now. They are brittle because they won't survive Transaction refactoring.If you ever want to refactor Transaction class you will have two choices:Refactor and waste time fixing tests. Convince yourself that Transaction is good as it is. Neither is a good choice.I want you to have a way to protect your future self by encapsulating test input preparation"],["entry@@protect-your-future-self-by-encapsulating-test-input-preparation@@test-input-initial-encapsulation","Entry","Protect Your Future Self By Encapsulating Test Input Preparation","Test Input Initial Encapsulation","Let's extract Transaction creation code into TestTransactions package com.example.portfolio; import org.junit.Test; import java.util.Arrays; import static com.example.portfolio.TestTransactions.createTransaction; import static org.junit.Assert.assertEquals; public class ProfitCalculatorWithBasicEncapsulationTest { private final ProfitCalculator profitCalculator = new ProfitCalculator(); @Test public void profitShouldBeZeroIfNoLotsSet() { Transaction t1 = createTransaction(\"t1\", \"SYM.B\", 0, 8); Transaction t2 = createTransaction(\"t2\", \"SYM.C\", 0, 19); assertEquals(0, profitCalculator.calculate(Arrays.asList(t1, t2)), 0); } } public static Transaction createTransaction(String id, String symbol, double lot, double price) { Transaction transaction = new Transaction(); transaction.setId(id); transaction.setSymbol(symbol); transaction.setLot(lot); transaction.setPrice(price); return transaction; } Less verbosity. A good start.Question: Can you still spot the problem? As we add more properties to Transaction class, some of the tests may need to set extra transaction properties. Additionally some of the properties will be completely irrelevant to the business logic under a test, yet you will be forced to set them anyway."],["entry@@protect-your-future-self-by-encapsulating-test-input-preparation@@test-input-encapsulation-with-webtau-table-data","Entry","Protect Your Future Self By Encapsulating Test Input Preparation","Test Input Encapsulation With Webtau Table Data","I was dealing with test problems like above for years and eventually came up with a solution that fits my needs. I hope it will fit your needs as well. The solution is to use flexible data structure like https://testingisdocumenting.org/webtau/reference/table-data Webtau TableData package com.example.portfolio; import org.junit.Test; import org.testingisdocumenting.webtau.data.table.TableData; import static com.example.portfolio.TestTransactions.createTransactions; import static org.testingisdocumenting.webtau.WebTauCore.*; // table and underscores are defined in WebTauCore public class ProfitCalculatorWithTableDataTest { private final ProfitCalculator profitCalculator = new ProfitCalculator(); @Test public void profitShouldBeZeroIfNoLotsSet() { TableData transactionsData = table( \"id\", \"symbol\", \"lot\", \"price\", // webtau TableData definition ________________________________, // header and values separator \"t1\", \"SYM.B\" , 0.0 , 8.0, \"t2\", \"SYM.C\" , 0.0 , 19.0); double margin = profitCalculator.calculate(createTransactions(transactionsData)); actual(margin).should(equal(0)); } } Note: https://github.com/testingisdocumenting/webtau Webtau is open source project that I started as my answer to common testing problems I encountered. public static List<Transaction> createTransactions(TableData tableData) { return tableData.rowsStream() .map(row -> { Transaction transaction = new Transaction(); transaction.setId(row.get(\"id\", genTransactionId())); // default value is auto generated transaction.setSymbol(row.get(\"symbol\")); transaction.setLot(row.get(\"lot\", 0.0)); // default value is hardcoded transaction.setPrice(row.get(\"price\", 0.0)); return transaction; }) .collect(toList()); } private static String genTransactionId() { return \"t-id-\" + idCount.incrementAndGet(); } Notice how createTransactions defaults values when they are not present? As a result of this, tests that don't need, say, id or lot are free to ignore them. @Test public void profitShouldBeZeroIfNoLotsSet() { TableData transactionsData = table(\"symbol\", \"lot\", ________________, \"SYM.B\" , 0.0, \"SYM.C\" , 0.0); double margin = profitCalculator.calculate(createTransactions(transactionsData)); actual(margin).should(equal(0)); } If later a new required property will be added to Transaction , you won't have to change all your existing tests. Instead you will update createTransaction with a new default value. The only time you will have to change the tests to use the new property is if the new property is affecting the logic under test.Essentially your test will use as little data to prove logic works as possible.Question: Why it is important to minimize the data in your test? Test is crucial to understanding complex business logic The more data the harder it to comprehend the logic We want business people to look at our data sets (stay tuned to see a good way to expose test data to business)"],["entry@@protect-your-future-self-by-encapsulating-test-input-preparation@@try-it-out","Entry","Protect Your Future Self By Encapsulating Test Input Preparation","Try it out","<dependency> <groupId>org.testingisdocumenting.webtau</groupId> <artifactId>webtau-core</artifactId> <version>1.25-SNAPSHOT</version> <scope>test</scope> </dependency> https://testingisdocumenting.org/webtau Webtau user guide https://github.com/testingisdocumenting/webtau Webtau github"],["entry@@protect-your-future-self-by-encapsulating-test-input-preparation@@summary","Entry","Protect Your Future Self By Encapsulating Test Input Preparation","Summary","Tests input preparation can be verbose and brittle. Identify core domain objects and provide a convenient way to create them. Use as little data as necessary to prove logic correctness. Default the rest."],["entry@@ultimate-end-to-end-test@@webtau","Entry","Ultimate End To End Test","WebTau","WebTau stands for Web Tests Automation. An open source tool, API, and a framework designed to simplify testing on multiple levels.What do I mean by multiple levels? Apps I develop often have these layers:REST/GraphQL API Web UI Command Line Database When I write end-to-end tests I test on one layer, and validate on the other. I write a test for a command line tool and validate that CLI updates REST resource. I write a test for Web UI and use GraphQL API to set up the initial data."],["entry@@ultimate-end-to-end-test@@game-store","Entry","Ultimate End To End Test","Game Store","We are going to test Game Store product. It has Web UI where you can see what games are available.It has CLI tool to help admins to manage the product. gs-admin list List of games g1 Slay The Spire card rpg 20.0 g2 Civilization 6 strategy 60.0 g3 Doom fps 60.0 g4 Last Of Us 2 adventure drama 60.0 g5 Inside adventure 10.0 g6 Hearthstone card 0.0 g7 Division 2 shooter rpg 30.0 g8 Assassin Creed Odyssey rpg 40.0 It has GraphQL and REST API to manage data. def query = ''' query { game(id: \"g1\") { title type } } ''' Game Store product puts all the data into a database. Below we are going to see how webtau lets you seamlessly test on different layers and use other layers to help with data validation."],["entry@@ultimate-end-to-end-test@@webtau-introduction","Entry","Ultimate End To End Test","WebTau Introduction","Before writing a test for Game Store, we are going to use https://jsonplaceholder.typicode.com/ JSON Placeholder website to demo basic webtau parts.Our goal is to get and validate a response from this end point: https://jsonplaceholder.typicode.com/todos/1 In webtau use scenario to define a test. Let's create a file and define our first scenario: scenario('basic http invocation') { http.get('https://jsonplaceholder.typicode.com/todos/1') { body.title.should == 'delectus aut autem' // automatic mapping of a field name to a JSON response completed.should == false // specifying body is optional } } Note: Most of the time we are going to use webtau as both API and command line runner. You can use webtau with JUnit5 and JUnit4 and pure Java if you prefer.To run a test, assuming webtau is in PATH : webtau httpBasics.groovy basic http invocation (httpBasics.groovy) > executing HTTP GET https://jsonplaceholder.typicode.com/todos/1 . body.title equals \"delectus aut autem\" matches: body.title: actual: \"delectus aut autem\" <java.lang.String> expected: \"delectus aut autem\" <java.lang.String> (36ms) . body.completed equals false matches: body.completed: actual: false <java.lang.Boolean> expected: false <java.lang.Boolean> (2ms) . header.statusCode equals 200 matches: header.statusCode: actual: 200 <java.lang.Integer> expected: 200 <java.lang.Integer> (0ms) response (application/json; charset=utf-8): { \"userId\": 1, \"id\": 1, \"title\": __\"delectus aut autem\"__, \"completed\": __false__ } . executed HTTP GET https://jsonplaceholder.typicode.com/todos/1 (317ms) Webtau captures everything that happens in a test:commands there were ran assertions that were made (both passed and failed) values that were checked ( __ in the console output) All the captured data is available after test run inside a rich html report that we are going to look at later."],["entry@@ultimate-end-to-end-test@@basic-configuration","Entry","Ultimate End To End Test","Basic Configuration","To avoid writing full url in our tests let's define a base url for our service, UI and define an additional environment: url = \"http://localhost:8080\" // base url for all http and browser requests browserUrl = \"http://localhost:3000\" // base url for browser open commands. Overrides url above if both are present browserId = \"firefox\" // specifying browser to use for browser based operations environments { dev { // optional overrides for the configs for dev environment url = \"http://dev-server:8080\" browserUrl = \"http://dev-server:8080\" } } scenario('implicit config usage') { http.post(\"/relative-url\") // implicit usage of core url config value browser.open(\"/test\") // implicit usage of browser url and browser id } You can override config values using CLI params. Use --env=<value> to select an environment, i.e. a different set of config values: webtau scenarios/* --env=dev --url=http://override-value --browserId=chrome"],["entry@@ultimate-end-to-end-test@@game-store-rest-api","Entry","Ultimate End To End Test","Game Store REST API","Let's test Game Store API to register and check a game by id. http://localhost:8080/api/game scenario('register new game') { http.post(\"/api/game\", [ id: \"g1\", // define payload as a map title: \"Slay The Spire\", type: \"card rpg\", priceUsd: 20]) http.get(\"/api/game/g1\") { // request newly created game as GET id.should == \"g1\" title.should == \"Slay The Spire\" // direct access to response JSON title property type.should == \"card rpg\" priceUsd.should == 20 } } Did you notice that request to POST and response from GET looks the same? Let's extract payload into a variable and re-use it for both request payload and response validation. This time we also not going to pass id to the request and instead rely on the server to generate a new ID. package scenarios.gamestore // optional package declaration for IDE happiness import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // optional single import for IDE autocomplete scenario('register new game') { def payload = [title: \"Slay The Spire\", // no ID specified this time type: \"card rpg\", priceUsd: 20] def id = http.post(\"/api/game\", payload) { return id // we grab id from response, return keyword is optional } http.get(\"/api/game/${id}\") { // using id for subsequent request body.should == payload // re-using POST payload to assert GET response. Only values in payload will be validated } }"],["entry@@ultimate-end-to-end-test@@http-explicit-auth","Entry","Ultimate End To End Test","HTTP Explicit Auth","End-point /api/game was not requiring authentication. It was done for exampleâ€™s sake to make it simpler to approach. Now let's test an end-point that requires auth. scenario('save preferences without auth') { http.put('/api/user-preferences', [favoriteGenre: 'RPG']) { statusCode.should == 403 // forbidden, as this end-point requires authentication } } To authenticate a user our system relies on Bearer token. Let's generate a token and explicitly pass it via header parameter. scenario('save preferences with explicit auth') { def token = generateToken('user-a') // generates token using our system underlying auth system http.put('/api/user-preferences', http.header([Authorization: \"Bearer ${token}\"]), // explicitly pass Bearer token [favoriteGenre: 'RPG']) { userId.should == 'user-a' // make sure server recognized token and properly authenticated user } }"],["entry@@ultimate-end-to-end-test@@personas","Entry","Ultimate End To End Test","Personas","Webtau provides a way to implement implicit authentication for your requests. Before we get there, we need to cover Persona concept. Persona sets the context for config values and code execution. userId = 'NA' // custom config value defined in the default context personas { // persona config section, similar to environments config section Alice { userId = \"uid-alice\" // Alice's specific config value } Bob { userId = \"uid-bob\" // Bob's specific config value } } def Alice = persona('Alice') // define Alice persona def Bob = persona('Bob') // define Bob persona scenario('persona demo') { println cfg.userId // custom value from config Alice { println cfg.userId // custom value from config in Alice's context } Bob { println cfg.userId // custom value from config in Bob's context } } persona demo (personaDemo.groovy) NA uid-alice uid-bob"],["entry@@ultimate-end-to-end-test@@http-implicit-auth","Entry","Ultimate End To End Test","HTTP Implicit Auth","Instead of explicitly passing header to each http call we will execute calls in the context of a persona. scenario('save preferences with personas auth') { Alice { // Alice's context http.put('/api/user-preferences', [favoriteGenre: 'RPG']) { userId.should == 'uid-alice' // validating that we updated the right user favoriteGenre.should == 'RPG' } } Bob { // Bob's context http.put('/api/user-preferences', [favoriteGenre: 'Strategy']) { userId.should == 'uid-bob' // validating that we updated the right user favoriteGenre.should == 'Strategy' } } } Console output (and report that we are going to look at later) captures what steps were executed in what context. running: scenarios/gamestore/userPreferencesRest.groovy save preferences with personas auth save preferences with personas auth (userPreferencesRest.groovy) > Alice executing HTTP PUT http://localhost:8080/api/user-preferences request (application/json): { \"favoriteGenre\": \"RPG\" } . Alice body.userId equals \"uid-alice\" matches: body.userId: actual: \"uid-alice\" <java.lang.String> expected: \"uid-alice\" <java.lang.String> (18ms) . Alice body.favoriteGenre equals \"RPG\" matches: body.favoriteGenre: actual: \"RPG\" <java.lang.String> expected: \"RPG\" <java.lang.String> (0ms) . Alice header.statusCode equals 200 matches: header.statusCode: actual: 200 <java.lang.Integer> expected: 200 <java.lang.Integer> (1ms) > Alice validating request and response . Alice validated request and response (149ms) response (application/json): { \"userId\": __\"uid-alice\"__, \"favoriteGenre\": __\"RPG\"__ } . Alice executed HTTP PUT http://localhost:8080/api/user-preferences (320ms) > Bob executing HTTP PUT http://localhost:8080/api/user-preferences To make sure our PUT worked as intended we are going to GET user preferences in different Persona contexts. scenario('read preferences with personas auth') { Alice { // Alice's context http.get('/api/user-preferences') { favoriteGenre.should == 'RPG' // we get back the Alice's favorite genre } } Bob { // Bob's context http.get('/api/user-preferences') { favoriteGenre.should == 'Strategy' // we get back the Bob's favorite genre } } } How does it work behind the covers? Webtau allows you to define an implicit HTTP Header Provider that can inject header values into each request. httpHeaderProvider = HttpHeaderProvider.&provide // implicit header provider userId = '' // explicitly set default userId to be an empty string personas { Alice { userId = 'uid-alice' // Alice's system specific user id } Bob { userId = 'uid-bob' // Bob's system specific user id } } Our custom implementation of HTTP Header Provider checks cfg.userId value and when it is present, it will be used to generate Bearer token and inject into ongoing request.Note: cfg.userId is only set in the context of Bob or Alice . Outside persona context userId is an empty value. package auth import org.testingisdocumenting.webtau.http.HttpHeader import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class HttpHeaderProvider { static provide(String fullUrl, String url, // provide method will be called for every HTTP request HttpHeader httpHeaders) { def userId = cfg.userId // grab custom userId config value, depends on the Persona context. Based on our current config, it is empty outside persona context. return userId ? httpHeaders.with(\"Authorization\", // create new http header by taking a header passed by a test explicitly and adding Authorization key-value \"Bearer ${generateToken(userId)}\"): httpHeaders // original header passed by a test } // generate token based on your auth system, dummy impl for the demo purposes only private static def generateToken(String userId) { return userId.bytes.encodeBase64().toString() } }"],["entry@@ultimate-end-to-end-test@@graphql","Entry","Ultimate End To End Test","GraphQL","We covered how to use http. namespace to test REST based API layer. Let's move to graphql. namespace to test GraphQL based API.Game Store provided a few queries and mutations: type Query { games: [Game] game(id: String): Game userPreferences: UserPreferences } type Mutation { createGame(id: String!, title: String!, type: String!, priceUsd: Int!): Game updateUserPreferences(favoriteGenre: String): UserPreferences } type Game { id: String title: String type: String priceUsd: Int } type UserPreferences { userId: String favoriteGenre: String } To start, we define a query to fetch a game by hardcoding id in the query. def query = ''' query { game(id: \"g1\") { title type } } ''' scenario('query game') { graphql.execute(query) { game.title.should == \"Slay The Spire\" // explicit access through query name title.should == \"Slay The Spire\" // implicit access in case of the single query } } GraphQL allows to define a query with parameters: def queryWithParams = ''' query game($id: String!) { game(id: $id) { title type } } ''' Webtau provides a way to pass parameter values as a Map : scenario('query game with param') { graphql.execute(queryWithParams, [id: 'g1']) { title.should == \"Slay The Spire\" } }"],["entry@@ultimate-end-to-end-test@@graphql-explicit-auth","Entry","Ultimate End To End Test","GraphQL Explicit Auth","As in REST based user preference example above, updateUserPreferences mutation requires authentication. def mutation = ''' mutation updateUserPreferences($favoriteGenre: String!) { updateUserPreferences(favoriteGenre: $favoriteGenre) { userId favoriteGenre } } ''' Unlike REST based API, the auth error appears in errors field on a response and not via statusCode : scenario('save preferences without auth') { graphql.execute(mutation, [favoriteGenre: 'CRPG']) { errors.message.should == ['forbidden'] // shortcut to take a message from each error in the list } } To do auth explicitly, similar to REST API, we can pass header as a parameter to graphql.execute : scenario('save preferences with explicit auth') { def token = generateToken('user-a') graphql.execute(mutation, [favoriteGenre: 'CRPG'], http.header([Authorization: \"Bearer ${token}\"])) { userId.should == 'user-a' } }"],["entry@@ultimate-end-to-end-test@@graphql-persona-auth","Entry","Ultimate End To End Test","GraphQL Persona Auth","Persona based authentication for GraphQL works exactly like REST API based one. scenario('save preferences with personas auth') { Alice { // Personas we defined and used for HTTP REST API graphql.execute(mutation, [favoriteGenre: 'RPG']) { userId.should == 'uid-alice' // make sure system picked Alice as a user favoriteGenre.should == 'RPG' } } Bob { graphql.execute(mutation, [favoriteGenre: 'Strategy']) { userId.should == 'uid-bob' // make sure system picked Bob as a user favoriteGenre.should == 'Strategy' } } } httpHeaderProvider = HttpHeaderProvider.&provide // implicit header provider userId = '' // explicitly set default userId to be an empty string personas { Alice { userId = 'uid-alice' // Alice's system specific user id } Bob { userId = 'uid-bob' // Bob's system specific user id } } package auth import org.testingisdocumenting.webtau.http.HttpHeader import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class HttpHeaderProvider { static provide(String fullUrl, String url, // provide method will be called for every HTTP request HttpHeader httpHeaders) { def userId = cfg.userId // grab custom userId config value, depends on the Persona context. Based on our current config, it is empty outside persona context. return userId ? httpHeaders.with(\"Authorization\", // create new http header by taking a header passed by a test explicitly and adding Authorization key-value \"Bearer ${generateToken(userId)}\"): httpHeaders // original header passed by a test } // generate token based on your auth system, dummy impl for the demo purposes only private static def generateToken(String userId) { return userId.bytes.encodeBase64().toString() } } Let's make system reflects the changes performed with mutations def query = ''' query { userPreferences { userId favoriteGenre } } ''' scenario('read preferences with personas auth') { Alice { graphql.execute(query) { favoriteGenre.should == 'RPG' // making sure correct data is returned back } } Bob { graphql.execute(query) { favoriteGenre.should == 'Strategy' // Strategy games are not bad } } }"],["entry@@ultimate-end-to-end-test@@personas-re-use","Entry","Ultimate End To End Test","Personas Re-use","We started with defining personas in-place within each test file like this: import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* def Alice = persona('Alice') // define Alice persona def Bob = persona('Bob') // define Bob persona scenario('persona demo') { println cfg.userId // custom value from config Alice { println cfg.userId // custom value from config in Alice's context } Bob { println cfg.userId // custom value from config in Bob's context } } As we start using Personas for multiple tests and multiple files it makes sense to define Personas once and reference them in tests as needed. package personas // user defined package name/directory import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class Personas { // class name can be anything public static final def Admin = persona('Admin') public static final def Alice = persona('Alice') public static final def Bob = persona('Bob') } To use defined personas we leverage Java/Groovy static import: package basicScenarios import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static personas.Personas.* // import all available personas to be in scope scenario('persona demo') { println cfg.userId Alice { // Alice is taken from personas.Personas.* println cfg.userId } Bob { println cfg.userId } }"],["entry@@ultimate-end-to-end-test@@browser","Entry","Ultimate End To End Test","Browser","We looked at how to test REST and GraphQL based APIs. Now let's move on to testing Web UI. Before we jump into testing Game Store UI, we will do a classic test of Google Page.Our test will enter \"test\" value into the search box and, wait for the results to show up and pick a result based on a regular expression: scenario('basic browser interaction') { browser.open(\"https://google.com\") $('input[title=\"Search\"]').setValue(\"test\\n\") // set value based on the underlying component $('h3').count.waitTo >= 1 // explicit, simplified wait on condition $(\"h3\").get(~/Speedtest.*Ookla/).click() // example of filter based on regular expression browser.url.full.should == ~/speedtest.net/ // full url assertion } As with REST and GraphQL, webtau console output captures all the actions that happen, and how much time each action took: basic browser interaction (browserBasics.groovy) preparing chrome WebDriver > opening https://google.com . opened https://google.com (461ms) > setting value test\\n to by css input[title=\"Search\"] > clearing by css input[title=\"Search\"] . cleared by css input[title=\"Search\"] (36ms) > sending keys test\\n to by css input[title=\"Search\"] . sent keys test\\n to by css input[title=\"Search\"] (936ms) . set value test\\n to by css input[title=\"Search\"] (1s 10ms) > waiting to count of by css h3 to be greater than or equal to 1 . count of by css h3 greater than or equal 1 matches: count: actual: 15 <java.lang.Integer> expected: greater than or equal to 1 <java.lang.Integer> (29ms) > clicking by css h3 , element(s) with regexp Speedtest.*Ookla . clicked by css h3 , element(s) with regexp Speedtest.*Ookla (774ms) > expecting full page url of browser to equal pattern /speedtest.net/ . full page url of browser equals pattern /speedtest.net/ matches: full page url: actual string: https://www.speedtest.net/ expected pattern: speedtest.net (4ms) Note: Both passed and failed assertions are captured."],["entry@@ultimate-end-to-end-test@@game-store-ui","Entry","Ultimate End To End Test","Game Store UI","The first Game Store page we are going to test is a landing page. It shows available games and let you filter based on text or price.We covered how to use http. layer to create new games. We can use that to prepare a setup for our UI test: package scenarios.gamestore import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('landing page') { http.post(\"/api/game\", [id: \"g1\", title: \"Slay The Spire\", type: \"card rpg\", priceUsd: 20]) // pre-create test data using HTTP http.post(\"/api/game\", [id: \"g2\", title: \"Civilization 6\", type: \"strategy\", priceUsd: 60]) http.post(\"/api/game\", [id: \"g3\", title: \"Doom\", type: \"fps\", priceUsd: 40]) browser.open(\"/\") // open landing page, relying on url and/or browserUrl def titles = $('[class*=\"GamesList_title\"]') // define titles as page element selected by css titles.waitTo == ['Civilization 6', 'Doom', 'Slay The Spire'] // wait for games titles to show up and match our expectations http.delete(\"/api/game/g3\") // delete a single game using HTTP titles.waitTo == ['Civilization 6', 'Slay The Spire'] // wait for UI to reflect changes } Let's test the filters: scenario('filter by text') { browser.reopen(\"/\") $(\"#filter\").setValue(\"civ\") // use setValue abstraction to set value inside input box $('[class*=\"GamesList_title\"]').waitTo == ['Civilization 6'] // wait for changes to be reflected } scenario('filter by price') { browser.reopen(\"/\") $(\"#below60\").setValue(true) // use setValue abstraction to set value for a checkbox $('[class*=\"GamesList_title\"]').waitTo == ['Doom', 'Slay The Spire'] // wait for changes to be reflected } Note: setValue is used for both text input box and check box. Webtau will figure out what actions to perform based on the underlying form element."],["entry@@ultimate-end-to-end-test@@ui-page-object","Entry","Ultimate End To End Test","UI Page Object","If you have experience in writing UI tests, you may have heard about https://martinfowler.com/bliki/PageObject.html Page Object pattern. Basic idea is to separate what user can see or do from technical details of how to simulate the actions or query the values.If we take a look at the code in our UI test we will see that details of how to locate elements on the UI are exposed. Any time we change id element or class names, we risk breaking our tests.Warning: Tests should not be broken if only implementation details has changed. $(\"#filter\").setValue(\"civ\") // exposing css selector to the test is going to haunt you later $('[class*=\"GamesList_title\"]').waitTo == ['Civilization 6'] // class based selection is more likely to become out of sync To implement page object in Webtau we will use a regular Java/Groovy/Kotlin class: package pages import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class LandingPage { def titles = $('[class*=\"GamesList_title\"]') def filterText = $(\"#filter\") // lazy declaration for future usage, no actual attempt to find element is performed def filterBelow60 = $(\"#below60\") def labelBelow60 = $(\"span\").get('Below $60') // filters chaining is also lazy def adminMessage = $(\"#admin-message\") def reopen() { browser.reopen(\"/\") } } Since our page object class is stateless and elements declarations are lazy, we can precreate instances of all the page objects in one place: package pages class Pages { static final def maintenance = new MaintenancePage() // pre-creating stateless instances static final def login = new LoginPage() static final def landing = new LandingPage() // for all the pages our test suite needs to have access static final def userPreferences = new UserPreferencesPage() } package scenarios.gamestore import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* import static pages.Pages.* // import all the pages into test scope scenario('filter by text') { landing.reopen() // set value using input defined in the page object landing.filterText.(\"civ\") landing.titles.waitTo == ['Civilization 6'] } scenario('filter by price') { landing.reopen() // set checkbox value using input defined in the page object landing.filterBelow60.setValue(true) landing.titles.waitTo == ['Doom', 'Slay The Spire'] }"],["entry@@ultimate-end-to-end-test@@waitto","Entry","Ultimate End To End Test","WaitTo","You saw waitTo in a couple of places already. Let's pause on the topic.Question: Why do we need waitTo and can we instead make should do the waiting?We could. However, semantics are important. I think it is important to distinct between an immediate result, and a result that becomes available over time.Are our users going to see the result right away? Is database going to have the result right away? Is command line going to print that line right away?Additionally waitTo is not specific for browser. layer. It can be used to wait on files content, console output, database data, etc. // waiting on query to finally return a value (eventual consistency) db.query(\"select * from games\").waitTo contain([title: \"Slay The Spire\"]) // waiting of file content to contain a line fs.textContent(\"my-file.txt\").waitTo contain('important line') def command = cli.runInBackground(\"admin-tool\") login.login(\"myname\", \"mypassword\") // waiting on command line tool to print important message command.output.waitTo contain(\"<myname> logged in\") Testing Is DocumentingTesting is Documenting is my moto. WaitTo semantics allow you to look at the test and get a better understanding of how system behaves. This is an example of a more subtle, more common definition of how tests can help you to understand the system.Later I will show you how to make tests help you with the actual documentation in a more explicit manner."],["entry@@ultimate-end-to-end-test@@browser-explicit-auth","Entry","Ultimate End To End Test","Browser Explicit Auth","Game Store have a page where users can update their user preferences.If we go to that page directly, we will be redirected to the login page instead.In order to test user preferences page, we have to choices:handle login explicitly handle login implicitly scenario('user preferences redirects to login') { userPreferences.open() // open user preferences page login.name.waitTo beVisible browser.url.ref.should == '/login' // but landed on login page login.login('uid-test', 'dummy-password') // explicitly enter user name and password userPreferences.userId.waitTo == 'uid-test' // after redirect we can see user preferences userPreferences.favoriteGenre.should == '' } package pages import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class UserPreferencesPage { def userId = $('#user-id') // user id to assert on def favoriteGenre = $('#favorite-genre') // genre to validate/set def saveButton = $('#save') def saveResultMessage = $('#save-result') def open() { browser.reopen(\"/#/user\") } def save() { // exposed action - regular method saveButton.click() } } package pages import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class LoginPage { def name = $('#name') // name to wait on def password = $('#password') def loginButton = $('#login') void login(name, password) { // action to login with this.name.setValue(name) this.password.setValue(password) loginButton.click() } } Explicit login approach works well if we go the page once, and we know that we haven't performed login yet. If on the other hand we need to get to that page as part of other scenario, we may face the case where we have already logged-in, and the code that assumed logic redirection will fail.To fix that we will need to add additional if-else logic that may complicate things a bit.Alternatively we can use an implicit login with Personas."],["entry@@ultimate-end-to-end-test@@browser-implicit-auth","Entry","Ultimate End To End Test","Browser Implicit Auth","Browser Implicit Auth in also Persona based. scenario('implicit login with persona') { Alice { // In the Alice's context http.put('/api/user-preferences', [favoriteGenre: 'RPG']) // prepare data to assert on - another example of http/browser test combination userPreferences.open() // open user preferences userPreferences.userId.waitTo == 'uid-alice' // we expect user preferences screen, not the login screen userPreferences.favoriteGenre.should == 'RPG' // our assertion matches what we set using REST API } } Let's now update preferences through UI and validate them using REST API: scenario('change preferences through UI') { Bob { http.put('/api/user-preferences', [favoriteGenre: 'Sim']) } // Set Bob's preference via HTTP Alice { userPreferences.open() userPreferences.favoriteGenre.waitTo beVisible() // wait for UI to load data from REST endpoint userPreferences.favoriteGenre.setValue('CRPG') userPreferences.save() // save user preferences userPreferences.saveResultMessage.waitTo == 'Saved' // wait for visual clue to appear } Bob { // In Bob's context http.get('/api/user-preferences') { favoriteGenre.should == 'Sim' // Bob's preferences were not affected by UI } } Alice { // In Alice's context http.get('/api/user-preferences') { favoriteGenre.should == 'CRPG' // Genre is the one we set } } } To make implicit auth work we need to implement browserPageNavigationHandler . A handler that will be called for each page open event. package auth import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class BrowserOpenHandler { private static STORAGE_KEY = 'authToken' static void handleOpen(passedUrl, fullUrl, currentUrl) { // will be called for every page open def userId = cfg.userId // take user from config based on current persona if (!userId || browser.localStorage.getItem(STORAGE_KEY)) { // if no user or token is inside storage, we don't need to do anything return } browser.localStorage.setItem(STORAGE_KEY, generateToken(userId)) // set a new auth token generated based on current persona browser.reopen(fullUrl) // re-open original page } // generate token based on your auth system, dummy impl for the demo purposes only private static def generateToken(String userId) { return userId.bytes.encodeBase64().toString() } } Note: Game Store UI code uses local storage to manage auth token. In your app it could be session storage or cookies. browserPageNavigationHandler = BrowserOpenHandler.&handleOpen // implicit page open handler userId = '' // explicitly set default userId to be an empty string personas { Alice { userId = 'uid-alice' // Alice's system specific user id } Bob { userId = 'uid-bob' // Bob's system specific user id } } Question: How do we maintain different localStorage for different Personas? Webtau maintains a browser per persona . In the examples above we have a total of two browsers during test run:Default browser Alice's browser"],["entry@@ultimate-end-to-end-test@@browser-websocket","Entry","Ultimate End To End Test","Browser WebSocket","Now that we know how to use Persona to manage multiple browsers, we can write a test for the last part of Game Store UI - admin page to send messages to visitors.Admin page allows to send a message to all visitors via WebSocket.In order to test this we will need two browsers: one to send a message and another to receive a websocket event.Let's start with defining a page object for the new page: package pages import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class MaintenancePage { def message = $('#message') def sendMessage = $('button').get('send message') def reopen() { browser.reopen(\"/#/admin\") } } package scenarios.gamestore import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* // single convenient import for IDE auto complete import static pages.Pages.* // convenient access to all page objects import static personas.Personas.* // convenient access to all Personas scenario('sending admin message') { landing.reopen() // open landing page in a default browser def message = 'Shop is going to be closed for maintenance' Admin { maintenance.reopen() // open maintenance page in Admin's browser maintenance.message.setValue(message) maintenance.sendMessage.click() // send notification message } landing.adminMessage.waitTo == message // in the default browser, wait for the message to arrive }"],["entry@@ultimate-end-to-end-test@@database","Entry","Ultimate End To End Test","Database","Another layer to explore is Database. Database layer can be used to prepare test data. It can also be used to validate data persistence after REST/GraphQL API calls.Warning: Database layer is often considered to be implementation details, and most of your tests should not use it directly. However, it can be useful to validate that REST POST method did modify data in the database and didn't persist data in cache only. scenario('http post and db list games') { db.update(\"delete from Game\") // wipe out table http.post(\"/api/game\", [id: \"g1\", title: \"Slay The Spire\", type: \"card rpg\", priceUsd: 20]) // create two games using HTTP http.post(\"/api/game\", [id: \"g2\", title: \"Civilization 6\", type: \"strategy\", priceUsd: 60]) def GAME = db.table(\"GAME\") GAME.should == [\"*ID\" | \"TITLE\"] { // make sure DB reflects changes __________________________ \"g1\" | \"Slay The Spire\" \"g2\" | \"Civilization 6\"} } scenario('db write and http list games') { db.update(\"delete from Game\") def GAME = db.table(\"GAME\") // populate GAME table with two rows GAME << [\"ID\" | \"TITLE\" | \"TYPE\" | \"PRICE_USD\"] { ____________________________________________________ \"g1\" | \"Slay The Spire\" | \"card rpg\" | 20 \"g2\" | \"Civilization 6\" | \"strategy\" | 60 } http.get(\"/api/game\") { // expect body to contain a list of two games body.should == [ \"*id\" | \"title\" ] { ___________________________ \"g2\" | \"Civilization 6\" \"g1\" | \"Slay The Spire\" } } }"],["entry@@ultimate-end-to-end-test@@cli-command","Entry","Ultimate End To End Test","CLI Command","Command line interface is our final layer to test. Before we test admin app, let's see how cli. works on a simple command: cli.run(\"ls -l\") cli.run(\"ls -l\") { output.should contain(\"webtau.cfg.groovy\") } total 1032 drwxr-xr-x 4 mykolagolubyev staff 128 Oct 27 16:39 auth drwxr-xr-x 13 mykolagolubyev staff 416 Oct 27 10:21 basicScenarios drwxr-xr-x 4 mykolagolubyev staff 128 Oct 27 10:21 clicommands drwxr-xr-x 3 mykolagolubyev staff 96 Oct 15 14:58 listeners drwxr-xr-x 8 mykolagolubyev staff 256 Oct 31 23:01 pages drwxr-xr-x 3 mykolagolubyev staff 96 Oct 31 22:59 personas drwxr-xr-x 8 mykolagolubyev staff 256 Oct 27 10:21 scenarios drwxr-xr-x 3 mykolagolubyev staff 96 Jul 29 13:24 test drwxr-xr-x 3 mykolagolubyev staff 96 Oct 23 20:21 utils -rw-r--r-- 1 mykolagolubyev staff 1071 Oct 31 20:38 webtau.cfg.groovy -rw-r--r-- 1 mykolagolubyev staff 500422 Oct 31 23:20 webtau.report.html Our admin CLI tool works similar ls and list games available in the system: List of games 6391a57f-7b59-4997-8459-1a8f88d3c0ab Slay The Spire card rpg 20.0 20cb8232-6515-4c2d-9046-acc990ab4c2d Civilization 6 strategy 60.0 We still develop the tool and it is not available in PATH yet, so we will need to use a relative path to run it. Exposing the path to tests will make our tests brittle in the similar way how exposing UI elements definition does: any time we change the tool location we will have to change tests using the tool.Similar to UI Page Object idea, we declare CLI tools our tests need access to in a separate file/class: package clicommands import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* class CliCommands { static final def adminTool = cli.command( // lazy declaration of our CLI command \"java -jar ../../../../game-store-cli/target/admin-tool-jar-with-dependencies.jar\") // command line location is subject to change and should not be exposed to a test } package scenarios.gamestore import static clicommands.CliCommands.* // convenient access to all declared command line tools import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('list games using CLI') { // cleaning up DB db.update(\"delete from GAME\") // run our command line adminTool.run { output.should contain(\"List of games\") // expect a title to be present, and nothing else output.numberOfLines.should == 1 } http.post(\"/api/game\", [title: \"Slay The Spire\", type: \"card rpg\", priceUsd: 20]) // pre-create data we need for the test using http layer http.post(\"/api/game\", [title: \"Civilization 6\", type: \"strategy\", priceUsd: 60]) adminTool.run { output.should contain(\"Slay The Spire\") // make sure output contains games we created output.should contain(\"Civilization 6\") } }"],["entry@@ultimate-end-to-end-test@@tabledata","Entry","Ultimate End To End Test","TableData","We have seen TableData usage when we worked with Database and when we validated complex REST API output. Let's take a closer look at it. TableData is a core webtau data type. Think of it as a list of maps with extra functionality. You can assign TableData to a variable, pass it around, return from functions and use for assertions. Data is available at runtime, and it is not a compile-time construct.Here is an example of usage of extra TableData features to generate test data: scenario('table data demo') { def increment = cell.above + 1 // create increment cell function to auto increase value def tableData = [\"id\" | \"name\" | \"score\" | \"type\" | \"disabled\"] { ____________________________________________________________________________ cell.guid | \"A\" | 100 | \"T0R\" | false // cell.guid generates guid cell.guid | \"B\" | cell.above | \"MBR\" | true // cell.above reuses value from the row above cell.guid | \"C\" | increment | permute(\"PO\", \"AC\") | permute(true, false) } // permute generates multiple rows based on the values passed println(\"table data:\") println(tableData) println(tableData.collect { it.score }) // standard collection operations are available on table data } table data demo (tableDataDemo.groovy) table data: :id |name|score|type |disabled: .______________________________________.____._____._____.________. |\"f982944c-3799-4738-b169-dfd85d588599\"|\"A\" |100 |\"T0R\"|false | .______________________________________.____._____._____.________| |\"61a70270-afe4-4180-80d2-d5ab1b561758\"|\"B\" |100 |\"MBR\"|true | .______________________________________.____._____._____.________| |\"e7cf8880-927d-4142-80db-2987c34b631e\"|\"C\" |101 |\"PO\" |true | .______________________________________.____._____._____.________| |\"93033ad0-9d1e-4951-bad6-b76257df4a0c\"|\"C\" |102 |\"AC\" |true | .______________________________________.____._____._____.________| |\"765b44c2-b0f7-4289-8641-425b56183778\"|\"C\" |103 |\"PO\" |false | .______________________________________.____._____._____.________| |\"e003ace6-3d83-4861-a845-2adbfb1fcc8d\"|\"C\" |104 |\"AC\" |false | .______________________________________.____._____._____.________| [100, 100, 101, 102, 103, 104]"],["entry@@ultimate-end-to-end-test@@can-i-use-tabledata-with-junit","Entry","Ultimate End To End Test","Can I Use TableData With JUnit?","It is worth noting that TableData is not specific to Groovy command line runner. In fact it can be used for example as JUnit5 test factory: package com.example.junit5 import org.junit.jupiter.api.TestFactory class DynamicTestsGroovyTest { @TestFactory // Junit5 test factory that expects Stream<DynamicTest> def \"test factory example\"() { [\"price\" | \"quantity\" | \"outcome\"] { ___________________________________ 10 | 30 | 300 -10 | 30 | -300 }.test { // test is a what generates DynamicTest from each row PriceCalculator.calculate(price, quantity).should == outcome } } } Moreover, TableData is not specific to Groovy and you can use Java syntax to define an instance: package com.example.junit5; import org.junit.jupiter.api.DynamicTest; import org.junit.jupiter.api.TestFactory; import org.testingisdocumenting.webtau.data.table.TableData; import org.testingisdocumenting.webtau.junit5.DynamicTests; import java.util.stream.Stream; import static org.testingisdocumenting.webtau.WebTauCore.*; // convenient single import for unit tests class DynamicTestsJavaTest { TableData useCases = table(\"price\", \"quantity\", \"outcome\", // java table definition ______________________________, 10 , 30, 300, -10 , 30, -300); @TestFactory public Stream<DynamicTest> testFactoryExample() { return DynamicTests.fromTable(useCases, r -> { // generate DynamicTest per row int price = r.get(\"price\"); int quantity = r.get(\"quantity\"); int outcome = r.get(\"outcome\"); actual(PriceCalculator.calculate(price, quantity)).should(equal(outcome)); }); } }"],["entry@@ultimate-end-to-end-test@@can-i-use-the-rest-with-junit","Entry","Ultimate End To End Test","Can I Use The Rest With JUnit?","Since we are talking about JUnit and Java, let me show you how to write a REST API test using JUnit5 and Java syntax: package com.example.junit5; import org.junit.jupiter.api.Test; import org.testingisdocumenting.webtau.junit5.WebTau; import java.util.Map; import static org.testingisdocumenting.webtau.WebTauDsl.*; // convenient import for Java @WebTau // optional annotation to include this test into web report public class PostGetJavaTest { @Test public void registerNewGame() { Map<String, Object> payload = aMapOf( // define payload as a map \"id\", \"g1\", \"title\", \"Slay The Spire\", \"type\", \"card rpg\", \"priceUsd\", 20); http.post(\"/api/game\", payload); // same post as in Groovy http.get(\"/api/game/g1\", (header, body) -> { body.get(\"title\").should(equal(\"Slay The Spire\")); // validating title field in the response }); } } In case of JUnit runner, webtau reads config values from webtau.properties resource file: url=http://localhost:8080"],["entry@@ultimate-end-to-end-test@@reporting","Entry","Ultimate End To End Test","Reporting","As I mentioned at the beginning, webtau captures a lot of information. Information is printed to the console, but also stored in a rich HTML report.Generated report is a self-contained HTML file that can be emailed, slacked or copied to a network drive. You don't need to have a server to look at the report. Open it in a browser, and you will get an interactive mini app.Report Summary page consist ofTests Runtime - shows overall time spend Tests success ratio - how many failed vs passed HTTP Coverage - how many REST API operations are covered (webtau uses optional Open API spec url to discover all the operations) Tests run Ratio - how many skipped vs ran HTTP calls time - high level stats on HTTP based APIs Let's click on ( 6 ) to get more details about skipped operations:Report switched from Tests view to HTTP Calls view ( 1 ). You can see the list of operations we yet to test on the left ( 2 ). Number of items on the left matches the number in the summary card ( 3 ). We can use panel at the bottom ( 4 ) to switch between skipped, total, passed operations or tests.Let's navigate from Summary tab to Overal HTTP Performance tab. The screen shows high level picture of how performant our server is under test load. While it is not a true performance test, it may give you an initial glance into things that may need a closer look.HTTP Operations Performance tab provides a performance information based on Open API defined operations.Let's get back to tests view ( 1 ) and select a test ( 2 ). First screen we are going to see is a test Summary ( 3 ) with high level information on time taken.If a test performed any HTTP calls, you going to see the HTTP Calls tab ( 1 ). It contains every HTTP call performed with captured request, response and assertions ( 2 and 3 ) information.If a test performed any CLI calls, you going to see the CLI Calls tab ( 1 ). It contains every CLI call performed with captured command, output and assertions ( 2 ) information.Every test also has Steps tab ( 1 ) that contains every step test performed, time it took, and what Persona if any performed the step ( 2 and 3 )"],["entry@@ultimate-end-to-end-test@@repl","Entry","Ultimate End To End Test","REPL","REPL stands for read-eval-print-loop. It is an interactive computer programming environment that helps with prototyping.You may have already used REPL if you usedJupyter Notebook iPython R MatLab webtau:000> 2 + 2 ===> 4 webtau:000> a = 5 ===> 5 webtau:000> a + 3 ===> 8 Question: Why are we talking about REPL in the context of end to end testing?We want to have a fast feedback loop.Browser, Servers, DB setup takes time Preserving context End to end tests - slow feedback REPL - speedup feedback loop The faster feedback the happier you are"],["entry@@ultimate-end-to-end-test@@repl-browser","Entry","Ultimate End To End Test","REPL Browser","Writing UI tests can be time-consuming. One of the reason is it takes time to open a browser, run your test, add an extra line to the test, repeat.Instead we can run webtau in repl mode like this webtau repl after that we can execute one command at a time, preserving context webtau:000> browser.open(\"https://google.com\") preparing chrome WebDriver > opening https://google.com . opened https://google.com (459ms) webtau:000> $('input[title=\"Search\"]') element is found: by css input[title=\"Search\"] getText(): getUnderlyingValue(): webtau:000> $('input[title=\"Search\"]').setValue(\"test\\n\") > setting value test\\n to by css input[title=\"Search\"] > clearing by css input[title=\"Search\"] . cleared by css input[title=\"Search\"] (37ms) > sending keys test\\n to by css input[title=\"Search\"] . sent keys test\\n to by css input[title=\"Search\"] (1s 987ms) . set value test\\n to by css input[title=\"Search\"] (2s 45ms) webtau:000> $('input[title=\"Search\"]') element is found: by css input[title=\"Search\"] getText(): getUnderlyingValue(): test webtau:000> $('h3') element is found: by css h3 getText(): Speedtest by Ookla - The Global Broadband Speed Test getUnderlyingValue(): Speedtest by Ookla - The Global Broadband Speed Test count: 15 webtau:000> $('h3').count.waitTo >= 0 > waiting to count of by css h3 to be greater than or equal to 0 . count of by css h3 greater than or equal 0 matches: count: actual: 15 <java.lang.Integer> expected: greater than or equal to 0 <java.lang.Integer> (7ms)"],["entry@@ultimate-end-to-end-test@@repl-database","Entry","Ultimate End To End Test","REPL Database","Database layer can be used to semi-automatically validate state of your system during experimentation. Or it can be used to quickly wipe or setup the data. I personally use it during active development to iterate faster. webtau:000> db.query(\"select * from Game\") > running DB query select * from Game on primary-db . ran DB query select * from Game on primary-db (29ms) ID , PRICE_USD, TITLE , TYPE \"g1\", 20.00, \"Slay The Spire\", \"card rpg\" \"g2\", 40.00, \"Doom\" , \"fps\""],["entry@@ultimate-end-to-end-test@@repl-test-selection","Entry","Ultimate End To End Test","REPL Test Selection","The true power of webtau REPL mode comes from combining Test runs and experimentation in one go. We can run webtau in repl mode and at the same time pass the test files we want to work with: webtau scenarios/gamestore/adminCliTool.groovy scenarios/gamestore/userPreferencesRest.groovy scenarios/gamestore/userPreferencesGraphQL.groovy scenarios/gamestore/userPreferencesUi.groovy repl webtau:000> ls Test files: 0 scenarios/gamestore/adminCliTool.groovy 1 scenarios/gamestore/userPreferencesRest.groovy 2 scenarios/gamestore/userPreferencesGraphQL.groovy 3 scenarios/gamestore/userPreferencesUi.groovy Once you list all test files, you can select one by https://testingisdocumenting.org/webtau/REPL/test-runs#test-file-selection either index or text webtau:000> s \"userPreferencesRest\" Test scenarios of scenarios/gamestore/userPreferencesRest.groovy: 0 save preferences without auth 1 save preferences with explicit auth 2 save preferences with personas auth 3 read preferences with personas auth After test file selection, you can run one or more scenarios on demand. webtau:000> r \"save preferences with personas auth\" running: scenarios/gamestore/userPreferencesRest.groovy save preferences with personas auth save preferences with personas auth (userPreferencesRest.groovy) > Alice executing HTTP PUT http://localhost:8080/api/user-preferences request (application/json): { \"favoriteGenre\": \"RPG\" } . Alice body.userId equals \"uid-alice\" matches: body.userId: actual: \"uid-alice\" <java.lang.String> expected: \"uid-alice\" <java.lang.String> (18ms) . Alice body.favoriteGenre equals \"RPG\" matches: body.favoriteGenre: actual: \"RPG\" <java.lang.String> expected: \"RPG\" <java.lang.String> (0ms) . Alice header.statusCode equals 200 matches: header.statusCode: actual: 200 <java.lang.Integer> expected: 200 <java.lang.Integer> (1ms) > Alice validating request and response . Alice validated request and response (149ms) response (application/json): { \"userId\": __\"uid-alice\"__, \"favoriteGenre\": __\"RPG\"__ } . Alice executed HTTP PUT http://localhost:8080/api/user-preferences (320ms) > Bob executing HTTP PUT http://localhost:8080/api/user-preferences When I write tests, I keep re-running ( r ) a current test under development, then experiment with a few lines in REPL mode, do some checks, update the test file and re-run it ( r ). Webtau will reload test file and pickup your changes.After each test run, context is preserved, browser is open in the last location, DB is up to date, and REST/GraphQL APIs are primed.Here is an example of running a db. query after a test run: webtau:000> db.query(\"select * from user_preferences\") > running DB query select * from user_preferences on primary-db . ran DB query select * from user_preferences on primary-db (30ms) USER_ID , FAVORITE_GENRE \"user-a\" , \"RPG\" \"uid-alice\", \"RPG\" \"uid-bob\" , \"Strategy\""],["entry@@ultimate-end-to-end-test@@testing-is-documenting","Entry","Ultimate End To End Test","Testing is Documenting","When we document things, we try them out and make sure they work as intended. When we test things, we follow happy paths and edge cases.Happy path tests often cover what our users will do. Happy path tests also often match the things we document.Documentation is hard: Mostly manual labor Often becomes outdated Question: How do we make documentation easier to write and maintain?Artifacts captureWe already have things in our codebase that we can use to help with our product documentation. Example code snippets, GraphQL schema files, basic config files.By writing happy path tests we can add a few more to the list:CLI Outputs HTTP responses Screenshots The major part of this content was generated by running testsWebtau console outputs your saw, the REST/GraphQL API response, Game Store and Webtau Report screenshots, all of it was automatially generated by running tests."],["entry@@ultimate-end-to-end-test@@capturing-test-artifacts","Entry","Ultimate End To End Test","Capturing Test Artifacts","When I was showing your snippets of code before I was hidding some code from your. Let's take a look. scenario('db write and http list games') { db.update(\"delete from Game\") def GAME = db.table(\"GAME\") GAME << [\"ID\" | \"TITLE\" | \"TYPE\" | \"PRICE_USD\"] { ____________________________________________________ \"g1\" | \"Slay The Spire\" | \"card rpg\" | 20 \"g2\" | \"Civilization 6\" | \"strategy\" | 60 } http.get(\"/api/game\") { body.should == [ \"*id\" | \"title\" ] { ___________________________ \"g2\" | \"Civilization 6\" \"g1\" | \"Slay The Spire\" } } http.doc.capture(\"game-store-list-after-db\") } http.doc.capture generates a directory with captured response, request, url, assertions, etc /api/game [ { \"id\" : \"g1\", \"title\" : \"Slay The Spire\", \"type\" : \"card rpg\", \"priceUsd\" : 20.0 }, { \"id\" : \"g2\", \"title\" : \"Civilization 6\", \"type\" : \"strategy\", \"priceUsd\" : 60.0 } ] [\"root[0].id\",\"root[0].title\",\"root[1].id\",\"root[1].title\"] To capture screenshots webtau has browser.doc.capture scenario('filter by price') { landing.reopen() landing.filterBelow60.setValue(true) landing.titles.waitTo == ['Doom', 'Slay The Spire'] browser.doc.withAnnotations( browser.doc.badge(landing.filterText).toTheRight(), browser.doc.badge(landing.labelBelow60).toTheRight()) .capture('admin-ui-filter') } In addition to the screenshot .png file webtau also captures annotations placement and type: { \"shapes\" : [ { \"id\" : \"circle1\", \"type\" : \"circle\", \"text\" : \"1\", \"color\" : \"a\", \"x\" : 224, \"y\" : 88, \"r\" : 15 }, { \"id\" : \"circle2\", \"type\" : \"circle\", \"text\" : \"2\", \"color\" : \"a\", \"x\" : 345, \"y\" : 88, \"r\" : 15 } ], \"pixelRatio\" : 2 } In case of CLI cli.doc.capture captures the command that was run, its output and assertions performed package scenarios.gamestore import static org.testingisdocumenting.webtau.WebTauGroovyDsl.* scenario('list games using CLI') { db.update(\"delete from GAME\") adminTool.run { output.should contain(\"List of games\") output.numberOfLines.should == 1 } http.post(\"/api/game\", [title: \"Civilization 6\", type: \"strategy\", priceUsd: 60]) adminTool.run { output.should contain(\"Civilization 6\") } cli.doc.capture(\"list-games-cli\") } java -jar ../../../../game-store-cli/target/admin-tool-jar-with-dependencies.jar List of games 6391a57f-7b59-4997-8459-1a8f88d3c0ab Slay The Spire card rpg 20.0 20cb8232-6515-4c2d-9046-acc990ab4c2d Civilization 6 strategy 60.0"],["entry@@ultimate-end-to-end-test@@example-of-generated-documentation","Entry","Ultimate End To End Test","Example of Generated Documentation","I used the captured information to generate the content of this blog/presentation. At my work I use captured artifacts to produce user guides. This approach makes guides to be always up-to date and validated.Here is an example of Game Store manual created with captured artifacts and https://testingisdocumenting.org/znai/ Znai documentation system."],["entry@@ultimate-end-to-end-test@@summary","Entry","Ultimate End To End Test","Summary","We tested Game Store on multiple layers, using one layer to set-up and re-inforce tests on the other layers. We used consistent matchers and concepts like should , waitTo , Persona across layers. We saw how each step and assertions is captured by webtau and written to console and rich HTML report. We saw how REPL can improve feedback loop and make you write tests faster. We saw how writing tests can generate artifacts to help you with writing User facing documentation."],["entry@@ultimate-end-to-end-test@@to-get-started","Entry","Ultimate End To End Test","To Get Started","WebTau - GitHub: https://github.com/testingisdocumenting/webtau https://github.com/testingisdocumenting/webtau WebTau - User Guide: https://testingisdocumenting.org/webtau https://testingisdocumenting.org/webtauZnai - Github: https://github.com/testingisdocumenting/znai https://github.com/testingisdocumenting/znai Znai - User Guide: https://testingisdocumenting.org/znai https://testingisdocumenting.org/znai"]]
/*
 * Copyright 2019 TWO SIGMA OPEN SOURCE, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

znaiSearchIdx = lunr(function () {
    this.ref('id')
    this.field('section')
    this.field('pageTitle')
    this.field('pageSection')
    this.field('text')

    this.metadataWhitelist = ['position']

    znaiSearchData.forEach(function (e) {
        this.add({
            id: e[0],
            section: e[1],
            pageTitle: e[2],
            pageSection: e[3],
            text: e[4],
        })
    }, this)
})
